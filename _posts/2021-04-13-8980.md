---
title : "Beakjoon 8980 배달"
categories: 
    - Algorithm
tag : 
    - 백준
    - 8980번
    - 배달
toc : true
---

### [Greedy] 8980번 배달



#### 문제

1번부터 N번까지 각각 번호가 붙어있는 마을이 있고 해당 각 마을에 물건을 배달합니다.

물건을 보내는 마을 번호, 물건을 받는 마을 번호, 보낼 박스의 개수가 주어집니다. 트럭을 통해 배달하는데 트럭에 운반할 수 있는 박스의 개수는 정해져있습니다. 이 트럭 한 대를 이용하여 최대한 많은 박스를 배송하려고 합니다.

다음의 조건을 모두 만족하는 답을 구하세요.

- 조건 1: 박스를 트럭에 실으면, 이 박스는 받는 마을에서만 내린다
- 조건 2: 트럭은 지나온 마을로 되돌아가지 않는다.
- 조간 3: 박스들 중 일부만 배송할 수도 있다.

입력 조건은 아래와 같다.

​	n : 마을 수(2~2,000이하 정수)

​	c : 트럭의 용량(1~10,000이하 정수)

​	m : 보내는 박스 정보의 개수(1~10,000이하의 정수)

​	그 아래에 출발지, 도착지, 박스의 수가 차례대로 주어진다.

```
4 40
6
3 4 20
1 2 10
1 3 20
1 4 30
2 3 10
2 4 20
```

------



#### 풀이

처음엔 생각한 방식은 주어진 모든 박스의 정보를 정렬하고, 전부를 돌면서 현재 박스의 최대 개수를 확인하는 방식으로 생각했지만, 계속 틀렸다는 결과만 확인할 수 있었다.

검색한 결과 훨씬 간단한 방법으로 해결할 수가 있었다. 간단하게 생각하면 도착지를 기준으로 보고 해당 도착지까지 몇 개의 박스를 운반할 수 있는지 생각하면 된다.

각 마을에 최대 박스의 개수만큼 박스를 가지고 있다고 가정해보자. (단, 4번 마을은 마지막 마을이므로 박스를 더 이상 실을 수 없기 때문에 따로 계산하지 않고 생략한다.)

|  1   |  2   |  3   |
| :--: | :--: | :--: |
|  40  |  40  |  40  |

처음 주어진 입력에서 우선 도착지 기준으로 정렬하자. 여기서 중요한 건 **도착지** 기준으로 생각해야 한다는 것이다. 도착해서 배송할 수 있는 박스를 기준으로 생각해야 하므로 도착지 기준으로 정렬하면 아래와 같다.

> 1 2 10
>
> 1 3 20
>
> 2 3 10
>
> 1 4 30
>
> 2 4 20
>
> 3 4 20

첫 번째 박스 정보를 확인하고 계산해보자. 출발지 1번 마을에서 2번 마을에 10개의 박스를 배송한다. 1번 마을에서 40개의 박스 중 10개를 실어야 하므로 40-10 = 30개의 박스가 남게 된다. 현재까지 배달한 박스의 개수는 **10개**이다.

|  1   |  2   |  3   |
| :--: | :--: | :--: |
|  30  |  40  |  40  |

두 번째 박스 정보를 확인하고 계산해보자. 출발지 1번 마을에서 3번 마을에 20개의 박스를 배송한다. 여기서 1번 마을과 2번 마을에 남은 적재 가능량 중 최솟값인 30은 배송해야 하는 20보다 크므로 1, 2번 마을 모두 20을 뺄 수 있다. 3번 마을에 배달하기 위해 1, 2번 마을에서 모두 가지고 있어야 하는 박스의 양이므로 1, 2번 마을에서 모두 빼준다. 현재까지 배달한 박스의 개수는 10+20 = **30개**이다.

|  1   |  2   |  3   |
| :--: | :--: | :--: |
|  10  |  20  |  40  |

세 번째 박스 정보를 확인하고 계산해보자. 출발지 2번 마을에서 3번 마을에 10개의 박스를 배송한다. 3번 마을에 배달하기 위해 2번에서만 박스를 실으면 되므로 2번에서 10을 빼준다. 현재까지 배달한 박스의 개수는 10+20+10 = **40개**이다.

|  1   |  2   |  3   |
| :--: | :--: | :--: |
|  10  |  10  |  40  |

네 번째 박스 정보를 확인하고 계산해보자. 출발지 1번 마을에서 4번 마을에 30개의 박스를 배송한다. 1,2,3번 마을의 가능 적재량 중 최솟값인 10은 현재 배달할 박스의 개수인 30보다 작다. 그러므로 최솟값인 10만 1,2,3번 마을에서 뺼 수 있다. <u>최소 적재량을 가진 1번 마을에서부터 4번 마을까지 가져와야 하므로 1번 마을에 현재 가능한 10개만 더 실을 수 있기 때문이다.</u> 현재까지 배달한 박스의 개수는 10+20+10+10 = **50개**이다.

|  1   |  2   |  3   |
| :--: | :--: | :--: |
|  0   |  0   |  30  |

다섯 번째 박스 정보를 확인하고 계산해보자. 출발지 2번 마을에서 4번 마을에 20개의 박스를 배송한다. 2,3번 마을의 가능 적재량 중 최솟값이 0이기 때문에 해당 박스는 2번 마을에서 더 이상 박스를 실을 수 없다. 그러므로 해당 박스는 배송이 불가능하다.

|  1   |  2   |  3   |
| :--: | :--: | :--: |
|  0   |  0   |  30  |

여섯 번째 박스 정보를 확인하고 계산해보자. 출발지 3번 마을에서 4번 마을에 20개의 박스를 배송한다. 3번 마을의 가능 적재량이 30이므로 20개의 박스 모두 배송 가능하다. 현재까지 배달한 박스의 개수는 10+20+10+10+20 = **70개**이다.

|  1   |  2   |  3   |
| :--: | :--: | :--: |
|  0   |  0   |  10  |



우선 출발지, 도착지, 박스 정보를 가진 클래스를 생성한다.

```java
class Delivery {
	int from;
	int to;
	int count;
	
	public Delivery(int from, int to, int count) {
		this.from = from;
		this.to = to;
		this.count = count;
	}
}
```

입력받은 박스의 정보를 Delivery List로 저장하고, 도착지를 기준으로 정렬한다. 여기서 도착지가 동일한 경우 출발지를 기준으로 오름차순 정렬을 한다.

```java
Collections.sort(dList, new Comparator<Delivery>() {
  @Override
  public int compare(Delivery o1, Delivery o2) {
    if (o1.to == o2.to) 		// 도착지가 같다면 출발지 기준으로 정렬 
      return o1.from - o2.from;
    else
      return o1.to - o2.to;	// 도착지 기준으로 정렬
  }
});
```

각 마을마다 가지고 있는 박스의 수를 알기 위해 마을의 수만큼 배열을 선언해둔다. 선언한 배열은 모두 최대 박스의 수로 초기화해둔다. 0에서 추가되는 박스를 더하는 것보다 최대 박스 개수에서 운반하는 박스의 개수를 0이 되기 전까지 빼는 방식이 훨씬 계산하기가 쉬웠다. 마을 번호대로 인덱스를 보기 위해 n+1크기로 선언한다.

```java
int[] town = new int[n+1];
for (int i=1; i<n+1; i++) {
  town[i] = c;
}
```

이제 배달할 수 있는 박스의 개수를 구해보자.

모든 박스 정보를 확인하면서 [출발지~도착지-1]까지의 마을의 박스 개수를 확인한다.  [출발지~도착지-1] 마을에서 적재할 수 있는 박스의 개수 중 가장 작은 한도를 가진 마을의 박스 개수를 구한다. 가장 작은 한도를 확인하며 운반할 수 있는 박스의 개수를 확인하여 배송 가능한 박스의 개수에 더해준다.

```java
for (int i=0; i<m; i++) {
  Delivery delivery = dList.get(i);

  // 보내는 마을과 받는 마을 사이에서 보낼 수 있는 최소 한도 구하기
  int minLimit = Integer.MAX_VALUE;
  for (int j=delivery.from; j<delivery.to; j++) {
    if (minLimit > town[j]) {
      minLimit = town[j];
    }
  }

  if (minLimit >= delivery.count) {
    // 최소 한도가 현재 운반해야하는 갯수보다 큰 경우
    for (int j=delivery.from; j<delivery.to; j++) {
      town[j] -= delivery.count;
    }
    answer += delivery.count;
  } else {
    // 최소 한도가 현재 운반해야하는 갯수보다 적은 경우
    for (int j=delivery.from; j<delivery.to; j++) {
      town[j] -= minLimit;
    }
    answer += minLimit;
  }
}
```

------



[전체 코드]
[Backjoon_greedy_8980](https://github.com/yuntnwls/codingtest/blob/4f1fd43152a82d9b1db15928493f0c49c142c50a/src/com/backjoon/greedy/t8980/Main.java)

[참조 블로그]
[https://steady-coding.tistory.com/58](https://steady-coding.tistory.com/58)
[https://steadev.tistory.com/15](https://steadev.tistory.com/15)

